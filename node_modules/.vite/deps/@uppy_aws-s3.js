import {
  BasePlugin
} from "./chunk-JTRRUC7P.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self = this;
      this._timer = setTimeout(function() {
        self._attempts++;
        if (self._operationTimeoutCb) {
          self._timeout = setTimeout(function() {
            self._operationTimeoutCb(self._attempts);
          }, self._operationTimeout);
          if (self._options.unref) {
            self._timeout.unref();
          }
        }
        self._fn(self._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self._operationTimeoutCb();
        }, self._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module) {
    module.exports = require_retry();
  }
});

// node_modules/@uppy/utils/lib/UserFacingApiError.js
var UserFacingApiError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "UserFacingApiError";
  }
};
var UserFacingApiError_default = UserFacingApiError;

// node_modules/p-retry/index.js
var import_retry = __toESM(require_retry2());

// node_modules/is-network-error/index.js
var objectToString = Object.prototype.toString;
var isError = (value) => objectToString.call(value) === "[object Error]";
var errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Load failed",
  // Safari 17+
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated"
  // Undici (Node.js)
]);
function isNetworkError(error) {
  const isValid = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid) {
    return false;
  }
  if (error.message === "Load failed") {
    return error.stack === void 0;
  }
  return errorMessages.has(error.message);
}

// node_modules/p-retry/index.js
var AbortError = class extends Error {
  constructor(message) {
    super();
    if (message instanceof Error) {
      this.originalError = message;
      ({ message } = message);
    } else {
      this.originalError = new Error(message);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message;
  }
};
var decorateErrorWithCounts = (error, attemptNumber, options) => {
  const retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
async function pRetry(input, options) {
  return new Promise((resolve, reject) => {
    options = { ...options };
    options.onFailedAttempt ?? (options.onFailedAttempt = () => {
    });
    options.shouldRetry ?? (options.shouldRetry = () => true);
    options.retries ?? (options.retries = 10);
    const operation = import_retry.default.operation(options);
    const abortHandler = () => {
      var _a;
      operation.stop();
      reject((_a = options.signal) == null ? void 0 : _a.reason);
    };
    if (options.signal && !options.signal.aborted) {
      options.signal.addEventListener("abort", abortHandler, { once: true });
    }
    const cleanUp = () => {
      var _a;
      (_a = options.signal) == null ? void 0 : _a.removeEventListener("abort", abortHandler);
      operation.stop();
    };
    operation.attempt(async (attemptNumber) => {
      try {
        const result = await input(attemptNumber);
        cleanUp();
        resolve(result);
      } catch (error) {
        try {
          if (!(error instanceof Error)) {
            throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
          }
          if (error instanceof AbortError) {
            throw error.originalError;
          }
          if (error instanceof TypeError && !isNetworkError(error)) {
            throw error;
          }
          decorateErrorWithCounts(error, attemptNumber, options);
          if (!await options.shouldRetry(error)) {
            operation.stop();
            reject(error);
          }
          await options.onFailedAttempt(error);
          if (!operation.retry(error)) {
            throw operation.mainError();
          }
        } catch (finalError) {
          decorateErrorWithCounts(finalError, attemptNumber, options);
          cleanUp();
          reject(finalError);
        }
      }
    });
  });
}

// node_modules/@uppy/utils/lib/NetworkError.js
var NetworkError = class extends Error {
  constructor(error, xhr) {
    if (xhr === void 0) {
      xhr = null;
    }
    super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);
    this.cause = error;
    this.isNetworkError = true;
    this.request = xhr;
  }
};
var NetworkError_default = NetworkError;

// node_modules/@uppy/utils/lib/fetchWithNetworkError.js
function fetchWithNetworkError() {
  return fetch(...arguments).catch((err) => {
    if (err.name === "AbortError") {
      throw err;
    } else {
      throw new NetworkError_default(err);
    }
  });
}

// node_modules/@uppy/utils/lib/hasProperty.js
function has(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}

// node_modules/@uppy/utils/lib/ErrorWithCause.js
var ErrorWithCause = class extends Error {
  constructor(message, options) {
    super(message);
    this.cause = options == null ? void 0 : options.cause;
    if (this.cause && has(this.cause, "isNetworkError")) {
      this.isNetworkError = this.cause.isNetworkError;
    } else {
      this.isNetworkError = false;
    }
  }
};
var ErrorWithCause_default = ErrorWithCause;

// node_modules/@uppy/utils/lib/getSocketHost.js
function getSocketHost(url) {
  var _regex$exec;
  const regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?([^\n]+)/i;
  const host = (_regex$exec = regex.exec(url)) == null ? void 0 : _regex$exec[1];
  const socketProtocol = /^http:\/\//i.test(url) ? "ws" : "wss";
  return `${socketProtocol}://${host}`;
}

// node_modules/@uppy/companion-client/lib/AuthError.js
var AuthError = class extends Error {
  constructor() {
    super("Authorization required");
    this.name = "AuthError";
    this.isAuthError = true;
  }
};
var AuthError_default = AuthError;

// node_modules/@uppy/companion-client/lib/RequestClient.js
function _classPrivateFieldLooseBase(e, t) {
  if (!{}.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id = 0;
function _classPrivateFieldLooseKey(e) {
  return "__private_" + id++ + "_" + e;
}
var packageJson = {
  "version": "4.4.2"
};
function stripSlash(url) {
  return url.replace(/\/$/, "");
}
var retryCount = 10;
var socketActivityTimeoutMs = 5 * 60 * 1e3;
var authErrorStatusCode = 401;
var HttpError = class extends Error {
  constructor(_ref) {
    let {
      statusCode,
      message
    } = _ref;
    super(message);
    this.name = "HttpError";
    this.statusCode = statusCode;
  }
};
async function handleJSONResponse(res) {
  if (res.status === authErrorStatusCode) {
    throw new AuthError_default();
  }
  if (res.ok) {
    return res.json();
  }
  let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;
  let errData;
  try {
    errData = await res.json();
    if (errData.message)
      errMsg = `${errMsg} message: ${errData.message}`;
    if (errData.requestId)
      errMsg = `${errMsg} request-Id: ${errData.requestId}`;
  } catch (cause) {
    throw new Error(errMsg, {
      cause
    });
  }
  if (res.status >= 400 && res.status <= 499 && errData.message) {
    throw new UserFacingApiError_default(errData.message);
  }
  throw new HttpError({
    statusCode: res.status,
    message: errMsg
  });
}
function emitSocketProgress(uploader, progressData, file) {
  const {
    progress,
    bytesUploaded,
    bytesTotal
  } = progressData;
  if (progress) {
    var _file$progress$upload;
    uploader.uppy.log(`Upload progress: ${progress}`);
    uploader.uppy.emit("upload-progress", file, {
      uploadStarted: (_file$progress$upload = file.progress.uploadStarted) != null ? _file$progress$upload : 0,
      bytesUploaded,
      bytesTotal
    });
  }
}
var _companionHeaders = _classPrivateFieldLooseKey("companionHeaders");
var _getUrl = _classPrivateFieldLooseKey("getUrl");
var _requestSocketToken = _classPrivateFieldLooseKey("requestSocketToken");
var _awaitRemoteFileUpload = _classPrivateFieldLooseKey("awaitRemoteFileUpload");
var RequestClient = class {
  constructor(uppy, opts) {
    Object.defineProperty(this, _awaitRemoteFileUpload, {
      value: _awaitRemoteFileUpload2
    });
    Object.defineProperty(this, _getUrl, {
      value: _getUrl2
    });
    Object.defineProperty(this, _companionHeaders, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _requestSocketToken, {
      writable: true,
      value: async (_ref2) => {
        var _file$remote;
        let {
          file,
          postBody,
          signal
        } = _ref2;
        if (((_file$remote = file.remote) == null ? void 0 : _file$remote.url) == null) {
          throw new Error("Cannot connect to an undefined URL");
        }
        const res = await this.post(file.remote.url, {
          ...file.remote.body,
          ...postBody
        }, {
          signal
        });
        return res.token;
      }
    });
    this.uppy = uppy;
    this.opts = opts;
    this.onReceiveResponse = this.onReceiveResponse.bind(this);
    _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders] = opts.companionHeaders;
  }
  setCompanionHeaders(headers) {
    _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders] = headers;
  }
  [Symbol.for("uppy test: getCompanionHeaders")]() {
    return _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders];
  }
  get hostname() {
    const {
      companion
    } = this.uppy.getState();
    const host = this.opts.companionUrl;
    return stripSlash(companion && companion[host] ? companion[host] : host);
  }
  async headers(emptyBody) {
    if (emptyBody === void 0) {
      emptyBody = false;
    }
    const defaultHeaders = {
      Accept: "application/json",
      ...emptyBody ? void 0 : {
        // Passing those headers on requests with no data forces browsers to first make a preflight request.
        "Content-Type": "application/json"
      }
    };
    return {
      ...defaultHeaders,
      ..._classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders]
    };
  }
  onReceiveResponse(res) {
    const {
      headers
    } = res;
    const state = this.uppy.getState();
    const companion = state.companion || {};
    const host = this.opts.companionUrl;
    if (headers.has("i-am") && headers.get("i-am") !== companion[host]) {
      this.uppy.setState({
        companion: {
          ...companion,
          [host]: headers.get("i-am")
        }
      });
    }
  }
  async request(_ref3) {
    let {
      path,
      method = "GET",
      data,
      skipPostResponse,
      signal
    } = _ref3;
    try {
      const headers = await this.headers(!data);
      const response = await fetchWithNetworkError(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
        method,
        signal,
        headers,
        credentials: this.opts.companionCookiesRule || "same-origin",
        body: data ? JSON.stringify(data) : null
      });
      if (!skipPostResponse)
        this.onReceiveResponse(response);
      return await handleJSONResponse(response);
    } catch (err) {
      if (err.isAuthError || err.name === "UserFacingApiError" || err.name === "AbortError")
        throw err;
      throw new ErrorWithCause_default(`Could not ${method} ${_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path)}`, {
        cause: err
      });
    }
  }
  async get(path, options) {
    return this.request({
      ...options,
      path
    });
  }
  async post(path, data, options) {
    return this.request({
      ...options,
      path,
      method: "POST",
      data
    });
  }
  async delete(path, data, options) {
    return this.request({
      ...options,
      path,
      method: "DELETE",
      data
    });
  }
  /**
   * Remote uploading consists of two steps:
   * 1. #requestSocketToken which starts the download/upload in companion and returns a unique token for the upload.
   * Then companion will halt the upload until:
   * 2. #awaitRemoteFileUpload is called, which will open/ensure a websocket connection towards companion, with the
   * previously generated token provided. It returns a promise that will resolve/reject once the file has finished
   * uploading or is otherwise done (failed, canceled)
   */
  async uploadRemoteFile(file, reqBody, options) {
    var _this = this;
    try {
      const {
        signal,
        getQueue
      } = options || {};
      return await pRetry(async () => {
        var _this$uppy$getFile;
        const existingServerToken = (_this$uppy$getFile = this.uppy.getFile(file.id)) == null ? void 0 : _this$uppy$getFile.serverToken;
        if (existingServerToken != null) {
          this.uppy.log(`Connecting to exiting websocket ${existingServerToken}`);
          return _classPrivateFieldLooseBase(this, _awaitRemoteFileUpload)[_awaitRemoteFileUpload]({
            file,
            queue: getQueue(),
            signal
          });
        }
        const queueRequestSocketToken = getQueue().wrapPromiseFunction(async function() {
          try {
            return await _classPrivateFieldLooseBase(_this, _requestSocketToken)[_requestSocketToken](...arguments);
          } catch (outerErr) {
            if (outerErr.isAuthError)
              throw new AbortError(outerErr);
            if (outerErr.cause == null)
              throw outerErr;
            const err = outerErr.cause;
            const isRetryableHttpError = () => [408, 409, 429, 418, 423].includes(err.statusCode) || err.statusCode >= 500 && err.statusCode <= 599 && ![501, 505].includes(err.statusCode);
            if (err.name === "HttpError" && !isRetryableHttpError())
              throw new AbortError(err);
            throw err;
          }
        }, {
          priority: -1
        });
        const serverToken = await queueRequestSocketToken({
          file,
          postBody: reqBody,
          signal
        }).abortOn(signal);
        if (!this.uppy.getFile(file.id))
          return void 0;
        this.uppy.setFileState(file.id, {
          serverToken
        });
        return _classPrivateFieldLooseBase(this, _awaitRemoteFileUpload)[_awaitRemoteFileUpload]({
          file: this.uppy.getFile(file.id),
          // re-fetching file because it might have changed in the meantime
          queue: getQueue(),
          signal
        });
      }, {
        retries: retryCount,
        signal,
        onFailedAttempt: (err) => this.uppy.log(`Retrying upload due to: ${err.message}`, "warning")
      });
    } catch (err) {
      if (err.name === "AbortError") {
        return void 0;
      }
      this.uppy.emit("upload-error", file, err);
      throw err;
    }
  }
};
function _getUrl2(url) {
  if (/^(https?:|)\/\//.test(url)) {
    return url;
  }
  return `${this.hostname}/${url}`;
}
async function _awaitRemoteFileUpload2(_ref4) {
  let {
    file,
    queue,
    signal
  } = _ref4;
  let removeEventHandlers;
  const {
    capabilities
  } = this.uppy.getState();
  try {
    return await new Promise((resolve, reject) => {
      const token = file.serverToken;
      const host = getSocketHost(file.remote.companionUrl);
      let socket;
      let socketAbortController;
      let activityTimeout;
      let {
        isPaused
      } = file;
      const socketSend = (action, payload) => {
        if (socket == null || socket.readyState !== socket.OPEN) {
          var _socket;
          this.uppy.log(`Cannot send "${action}" to socket ${file.id} because the socket state was ${String((_socket = socket) == null ? void 0 : _socket.readyState)}`, "warning");
          return;
        }
        socket.send(JSON.stringify({
          action,
          payload: payload != null ? payload : {}
        }));
      };
      function sendState() {
        if (!capabilities.resumableUploads)
          return;
        if (isPaused)
          socketSend("pause");
        else
          socketSend("resume");
      }
      const createWebsocket = async () => {
        if (socketAbortController)
          socketAbortController.abort();
        socketAbortController = new AbortController();
        const onFatalError = (err) => {
          var _socketAbortControlle;
          this.uppy.setFileState(file.id, {
            serverToken: null
          });
          (_socketAbortControlle = socketAbortController) == null || _socketAbortControlle.abort == null || _socketAbortControlle.abort();
          reject(err);
        };
        function resetActivityTimeout() {
          clearTimeout(activityTimeout);
          if (isPaused)
            return;
          activityTimeout = setTimeout(() => onFatalError(new Error("Timeout waiting for message from Companion socket")), socketActivityTimeoutMs);
        }
        try {
          await queue.wrapPromiseFunction(async () => {
            const reconnectWebsocket = async () => (
              // eslint-disable-next-line promise/param-names
              new Promise((_, rejectSocket) => {
                socket = new WebSocket(`${host}/api/${token}`);
                resetActivityTimeout();
                socket.addEventListener("close", () => {
                  socket = void 0;
                  rejectSocket(new Error("Socket closed unexpectedly"));
                });
                socket.addEventListener("error", (error) => {
                  var _socket2;
                  this.uppy.log(`Companion socket error ${JSON.stringify(error)}, closing socket`, "warning");
                  (_socket2 = socket) == null || _socket2.close();
                });
                socket.addEventListener("open", () => {
                  sendState();
                });
                socket.addEventListener("message", (e) => {
                  resetActivityTimeout();
                  try {
                    const {
                      action,
                      payload
                    } = JSON.parse(e.data);
                    switch (action) {
                      case "progress": {
                        emitSocketProgress(this, payload, this.uppy.getFile(file.id));
                        break;
                      }
                      case "success": {
                        var _payload$response, _payload$response$sta, _payload$response2, _socketAbortControlle2;
                        const text = (_payload$response = payload.response) == null ? void 0 : _payload$response.responseText;
                        this.uppy.emit("upload-success", this.uppy.getFile(file.id), {
                          uploadURL: payload.url,
                          status: (_payload$response$sta = (_payload$response2 = payload.response) == null ? void 0 : _payload$response2.status) != null ? _payload$response$sta : 200,
                          body: text ? JSON.parse(text) : void 0
                        });
                        (_socketAbortControlle2 = socketAbortController) == null || _socketAbortControlle2.abort == null || _socketAbortControlle2.abort();
                        resolve();
                        break;
                      }
                      case "error": {
                        const {
                          message
                        } = payload.error;
                        throw Object.assign(new Error(message), {
                          cause: payload.error
                        });
                      }
                      default:
                        this.uppy.log(`Companion socket unknown action ${action}`, "warning");
                    }
                  } catch (err) {
                    onFatalError(err);
                  }
                });
                const closeSocket = () => {
                  this.uppy.log(`Closing socket ${file.id}`);
                  clearTimeout(activityTimeout);
                  if (socket)
                    socket.close();
                  socket = void 0;
                };
                socketAbortController.signal.addEventListener("abort", () => {
                  closeSocket();
                });
              })
            );
            await pRetry(reconnectWebsocket, {
              retries: retryCount,
              signal: socketAbortController.signal,
              onFailedAttempt: () => {
                if (socketAbortController.signal.aborted)
                  return;
                this.uppy.log(`Retrying websocket ${file.id}`);
              }
            });
          })().abortOn(socketAbortController.signal);
        } catch (err) {
          if (socketAbortController.signal.aborted)
            return;
          onFatalError(err);
        }
      };
      const pause = (newPausedState) => {
        if (!capabilities.resumableUploads)
          return;
        isPaused = newPausedState;
        if (socket)
          sendState();
      };
      const onFileRemove = (targetFile) => {
        var _socketAbortControlle3;
        if (!capabilities.individualCancellation)
          return;
        if (targetFile.id !== file.id)
          return;
        socketSend("cancel");
        (_socketAbortControlle3 = socketAbortController) == null || _socketAbortControlle3.abort == null || _socketAbortControlle3.abort();
        this.uppy.log(`upload ${file.id} was removed`);
        resolve();
      };
      const onCancelAll = () => {
        var _socketAbortControlle4;
        socketSend("cancel");
        (_socketAbortControlle4 = socketAbortController) == null || _socketAbortControlle4.abort == null || _socketAbortControlle4.abort();
        this.uppy.log(`upload ${file.id} was canceled`);
        resolve();
      };
      const onFilePausedChange = (targetFile, newPausedState) => {
        if ((targetFile == null ? void 0 : targetFile.id) !== file.id)
          return;
        pause(newPausedState);
      };
      const onPauseAll = () => pause(true);
      const onResumeAll = () => pause(false);
      this.uppy.on("file-removed", onFileRemove);
      this.uppy.on("cancel-all", onCancelAll);
      this.uppy.on("upload-pause", onFilePausedChange);
      this.uppy.on("pause-all", onPauseAll);
      this.uppy.on("resume-all", onResumeAll);
      removeEventHandlers = () => {
        this.uppy.off("file-removed", onFileRemove);
        this.uppy.off("cancel-all", onCancelAll);
        this.uppy.off("upload-pause", onFilePausedChange);
        this.uppy.off("pause-all", onPauseAll);
        this.uppy.off("resume-all", onResumeAll);
      };
      signal.addEventListener("abort", () => {
        var _socketAbortControlle5;
        (_socketAbortControlle5 = socketAbortController) == null || _socketAbortControlle5.abort();
      });
      createWebsocket();
    });
  } finally {
    removeEventHandlers == null || removeEventHandlers();
  }
}
RequestClient.VERSION = packageJson.version;

// node_modules/@uppy/companion-client/lib/Provider.js
var id2 = 0;
function _classPrivateFieldLooseKey2(e) {
  return "__private_" + id2++ + "_" + e;
}
var _refreshingTokenPromise = _classPrivateFieldLooseKey2("refreshingTokenPromise");
var _getAuthToken = _classPrivateFieldLooseKey2("getAuthToken");
var _getPlugin = _classPrivateFieldLooseKey2("getPlugin");

// node_modules/@uppy/core/lib/EventManager.js
function _classPrivateFieldLooseBase2(e, t) {
  if (!{}.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id3 = 0;
function _classPrivateFieldLooseKey3(e) {
  return "__private_" + id3++ + "_" + e;
}
var _uppy = _classPrivateFieldLooseKey3("uppy");
var _events = _classPrivateFieldLooseKey3("events");
var EventManager = class {
  constructor(uppy) {
    Object.defineProperty(this, _uppy, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _events, {
      writable: true,
      value: []
    });
    _classPrivateFieldLooseBase2(this, _uppy)[_uppy] = uppy;
  }
  on(event, fn) {
    _classPrivateFieldLooseBase2(this, _events)[_events].push([event, fn]);
    return _classPrivateFieldLooseBase2(this, _uppy)[_uppy].on(event, fn);
  }
  remove() {
    for (const [event, fn] of _classPrivateFieldLooseBase2(this, _events)[_events].splice(0)) {
      _classPrivateFieldLooseBase2(this, _uppy)[_uppy].off(event, fn);
    }
  }
  onFilePause(fileID, cb) {
    this.on("upload-pause", (file, isPaused) => {
      if (fileID === (file == null ? void 0 : file.id)) {
        cb(isPaused);
      }
    });
  }
  onFileRemove(fileID, cb) {
    this.on("file-removed", (file) => {
      if (fileID === file.id)
        cb(file.id);
    });
  }
  onPause(fileID, cb) {
    this.on("upload-pause", (file, isPaused) => {
      if (fileID === (file == null ? void 0 : file.id)) {
        cb(isPaused);
      }
    });
  }
  onRetry(fileID, cb) {
    this.on("upload-retry", (file) => {
      if (fileID === (file == null ? void 0 : file.id)) {
        cb();
      }
    });
  }
  onRetryAll(fileID, cb) {
    this.on("retry-all", () => {
      if (!_classPrivateFieldLooseBase2(this, _uppy)[_uppy].getFile(fileID))
        return;
      cb();
    });
  }
  onPauseAll(fileID, cb) {
    this.on("pause-all", () => {
      if (!_classPrivateFieldLooseBase2(this, _uppy)[_uppy].getFile(fileID))
        return;
      cb();
    });
  }
  onCancelAll(fileID, eventHandler) {
    var _this = this;
    this.on("cancel-all", function() {
      if (!_classPrivateFieldLooseBase2(_this, _uppy)[_uppy].getFile(fileID))
        return;
      eventHandler(...arguments);
    });
  }
  onResumeAll(fileID, cb) {
    this.on("resume-all", () => {
      if (!_classPrivateFieldLooseBase2(this, _uppy)[_uppy].getFile(fileID))
        return;
      cb();
    });
  }
};

// node_modules/@uppy/utils/lib/RateLimitedQueue.js
function _classPrivateFieldLooseBase3(e, t) {
  if (!{}.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id4 = 0;
function _classPrivateFieldLooseKey4(e) {
  return "__private_" + id4++ + "_" + e;
}
function createCancelError(cause) {
  return new Error("Cancelled", {
    cause
  });
}
function abortOn(signal) {
  if (signal != null) {
    var _this$then;
    const abortPromise = () => this.abort(signal.reason);
    signal.addEventListener("abort", abortPromise, {
      once: true
    });
    const removeAbortListener = () => {
      signal.removeEventListener("abort", abortPromise);
    };
    (_this$then = this.then) == null || _this$then.call(this, removeAbortListener, removeAbortListener);
  }
  return this;
}
var _activeRequests = _classPrivateFieldLooseKey4("activeRequests");
var _queuedHandlers = _classPrivateFieldLooseKey4("queuedHandlers");
var _paused = _classPrivateFieldLooseKey4("paused");
var _pauseTimer = _classPrivateFieldLooseKey4("pauseTimer");
var _downLimit = _classPrivateFieldLooseKey4("downLimit");
var _upperLimit = _classPrivateFieldLooseKey4("upperLimit");
var _rateLimitingTimer = _classPrivateFieldLooseKey4("rateLimitingTimer");
var _call = _classPrivateFieldLooseKey4("call");
var _queueNext = _classPrivateFieldLooseKey4("queueNext");
var _next = _classPrivateFieldLooseKey4("next");
var _queue = _classPrivateFieldLooseKey4("queue");
var _dequeue = _classPrivateFieldLooseKey4("dequeue");
var _resume = _classPrivateFieldLooseKey4("resume");
var _increaseLimit = _classPrivateFieldLooseKey4("increaseLimit");
var RateLimitedQueue = class {
  constructor(limit) {
    Object.defineProperty(this, _dequeue, {
      value: _dequeue2
    });
    Object.defineProperty(this, _queue, {
      value: _queue2
    });
    Object.defineProperty(this, _next, {
      value: _next2
    });
    Object.defineProperty(this, _queueNext, {
      value: _queueNext2
    });
    Object.defineProperty(this, _call, {
      value: _call2
    });
    Object.defineProperty(this, _activeRequests, {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, _queuedHandlers, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _paused, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _pauseTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _downLimit, {
      writable: true,
      value: 1
    });
    Object.defineProperty(this, _upperLimit, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _rateLimitingTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _resume, {
      writable: true,
      value: () => this.resume()
    });
    Object.defineProperty(this, _increaseLimit, {
      writable: true,
      value: () => {
        if (_classPrivateFieldLooseBase3(this, _paused)[_paused]) {
          _classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _increaseLimit)[_increaseLimit], 0);
          return;
        }
        _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] = this.limit;
        this.limit = Math.ceil((_classPrivateFieldLooseBase3(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit]) / 2);
        for (let i = _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit]; i <= this.limit; i++) {
          _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
        }
        if (_classPrivateFieldLooseBase3(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] > 3) {
          _classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _increaseLimit)[_increaseLimit], 2e3);
        } else {
          _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] / 2);
        }
      }
    });
    if (typeof limit !== "number" || limit === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit;
    }
  }
  run(fn, queueOptions) {
    if (!_classPrivateFieldLooseBase3(this, _paused)[_paused] && _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] < this.limit) {
      return _classPrivateFieldLooseBase3(this, _call)[_call](fn);
    }
    return _classPrivateFieldLooseBase3(this, _queue)[_queue](fn, queueOptions);
  }
  wrapSyncFunction(fn, queueOptions) {
    var _this = this;
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const queuedRequest = _this.run(() => {
        fn(...args);
        queueMicrotask(() => queuedRequest.done());
        return () => {
        };
      }, queueOptions);
      return {
        abortOn,
        abort() {
          queuedRequest.abort();
        }
      };
    };
  }
  wrapPromiseFunction(fn, queueOptions) {
    var _this2 = this;
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      let queuedRequest;
      const outerPromise = new Promise((resolve, reject) => {
        queuedRequest = _this2.run(() => {
          let cancelError;
          let innerPromise;
          try {
            innerPromise = Promise.resolve(fn(...args));
          } catch (err) {
            innerPromise = Promise.reject(err);
          }
          innerPromise.then((result) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve(result);
            }
          }, (err) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err);
            }
          });
          return (cause) => {
            cancelError = createCancelError(cause);
          };
        }, queueOptions);
      });
      outerPromise.abort = (cause) => {
        queuedRequest.abort(cause);
      };
      outerPromise.abortOn = abortOn;
      return outerPromise;
    };
  }
  resume() {
    _classPrivateFieldLooseBase3(this, _paused)[_paused] = false;
    clearTimeout(_classPrivateFieldLooseBase3(this, _pauseTimer)[_pauseTimer]);
    for (let i = 0; i < this.limit; i++) {
      _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
    }
  }
  /**
   * Freezes the queue for a while or indefinitely.
   *
   * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.
   *                                    If omitted, the queue won't resume automatically.
   */
  pause(duration) {
    if (duration === void 0) {
      duration = null;
    }
    _classPrivateFieldLooseBase3(this, _paused)[_paused] = true;
    clearTimeout(_classPrivateFieldLooseBase3(this, _pauseTimer)[_pauseTimer]);
    if (duration != null) {
      _classPrivateFieldLooseBase3(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _resume)[_resume], duration);
    }
  }
  /**
   * Pauses the queue for a duration, and lower the limit of concurrent requests
   * when the queue resumes. When the queue resumes, it tries to progressively
   * increase the limit in `this.#increaseLimit` until another call is made to
   * `this.rateLimit`.
   * Call this function when using the RateLimitedQueue for network requests and
   * the remote server responds with 429 HTTP code.
   *
   * @param {number} duration in milliseconds.
   */
  rateLimit(duration) {
    clearTimeout(_classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer]);
    this.pause(duration);
    if (this.limit > 1 && Number.isFinite(this.limit)) {
      _classPrivateFieldLooseBase3(this, _upperLimit)[_upperLimit] = this.limit - 1;
      this.limit = _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit];
      _classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _increaseLimit)[_increaseLimit], duration);
    }
  }
  get isPaused() {
    return _classPrivateFieldLooseBase3(this, _paused)[_paused];
  }
};
function _call2(fn) {
  _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] += 1;
  let done = false;
  let cancelActive;
  try {
    cancelActive = fn();
  } catch (err) {
    _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] -= 1;
    throw err;
  }
  return {
    abort: (cause) => {
      if (done)
        return;
      done = true;
      _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] -= 1;
      cancelActive == null || cancelActive(cause);
      _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
    },
    done: () => {
      if (done)
        return;
      done = true;
      _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] -= 1;
      _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
    }
  };
}
function _queueNext2() {
  queueMicrotask(() => _classPrivateFieldLooseBase3(this, _next)[_next]());
}
function _next2() {
  if (_classPrivateFieldLooseBase3(this, _paused)[_paused] || _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] >= this.limit) {
    return;
  }
  if (_classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].length === 0) {
    return;
  }
  const next = _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].shift();
  if (next == null) {
    throw new Error("Invariant violation: next is null");
  }
  const handler = _classPrivateFieldLooseBase3(this, _call)[_call](next.fn);
  next.abort = handler.abort;
  next.done = handler.done;
}
function _queue2(fn, options) {
  const handler = {
    fn,
    priority: (options == null ? void 0 : options.priority) || 0,
    abort: () => {
      _classPrivateFieldLooseBase3(this, _dequeue)[_dequeue](handler);
    },
    done: () => {
      throw new Error("Cannot mark a queued request as done: this indicates a bug");
    }
  };
  const index = _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].findIndex((other) => {
    return handler.priority > other.priority;
  });
  if (index === -1) {
    _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].push(handler);
  } else {
    _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);
  }
  return handler;
}
function _dequeue2(handler) {
  const index = _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);
  if (index !== -1) {
    _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);
  }
}
var internalRateLimitedQueue = Symbol("__queue");

// node_modules/@uppy/utils/lib/fileFilters.js
function filterNonFailedFiles(files) {
  const hasError = (file) => "error" in file && !!file.error;
  return files.filter((file) => !hasError(file));
}
function filterFilesToEmitUploadStarted(files) {
  return files.filter((file) => {
    var _file$progress;
    return !((_file$progress = file.progress) != null && _file$progress.uploadStarted) || !file.isRestored;
  });
}

// node_modules/@uppy/utils/lib/AbortController.js
var {
  AbortController: AbortController2
} = globalThis;
var {
  AbortSignal
} = globalThis;
var createAbortError = function(message, options) {
  if (message === void 0) {
    message = "Aborted";
  }
  const err = new DOMException(message, "AbortError");
  if (options != null && has(options, "cause")) {
    Object.defineProperty(err, "cause", {
      // @ts-expect-error TS is drunk
      __proto__: null,
      configurable: true,
      writable: true,
      value: options.cause
    });
  }
  return err;
};

// node_modules/@uppy/utils/lib/getAllowedMetaFields.js
function getAllowedMetaFields(fields, meta) {
  if (fields === true) {
    return Object.keys(meta);
  }
  if (Array.isArray(fields)) {
    return fields;
  }
  return [];
}

// node_modules/@uppy/aws-s3/lib/MultipartUploader.js
function _classPrivateFieldLooseBase4(e, t) {
  if (!{}.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id5 = 0;
function _classPrivateFieldLooseKey5(e) {
  return "__private_" + id5++ + "_" + e;
}
var MB = 1024 * 1024;
var defaultOptions = {
  getChunkSize(file) {
    return Math.ceil(file.size / 1e4);
  },
  onProgress() {
  },
  onPartComplete() {
  },
  onSuccess() {
  },
  onError(err) {
    throw err;
  }
};
function ensureInt(value) {
  if (typeof value === "string") {
    return parseInt(value, 10);
  }
  if (typeof value === "number") {
    return value;
  }
  throw new TypeError("Expected a number");
}
var pausingUploadReason = Symbol("pausing upload, not an actual error");
var _abortController = _classPrivateFieldLooseKey5("abortController");
var _chunks = _classPrivateFieldLooseKey5("chunks");
var _chunkState = _classPrivateFieldLooseKey5("chunkState");
var _data = _classPrivateFieldLooseKey5("data");
var _file = _classPrivateFieldLooseKey5("file");
var _uploadHasStarted = _classPrivateFieldLooseKey5("uploadHasStarted");
var _onError = _classPrivateFieldLooseKey5("onError");
var _onSuccess = _classPrivateFieldLooseKey5("onSuccess");
var _shouldUseMultipart = _classPrivateFieldLooseKey5("shouldUseMultipart");
var _isRestoring = _classPrivateFieldLooseKey5("isRestoring");
var _onReject = _classPrivateFieldLooseKey5("onReject");
var _maxMultipartParts = _classPrivateFieldLooseKey5("maxMultipartParts");
var _minPartSize = _classPrivateFieldLooseKey5("minPartSize");
var _initChunks = _classPrivateFieldLooseKey5("initChunks");
var _createUpload = _classPrivateFieldLooseKey5("createUpload");
var _resumeUpload = _classPrivateFieldLooseKey5("resumeUpload");
var _onPartProgress = _classPrivateFieldLooseKey5("onPartProgress");
var _onPartComplete = _classPrivateFieldLooseKey5("onPartComplete");
var _abortUpload = _classPrivateFieldLooseKey5("abortUpload");
var MultipartUploader = class {
  constructor(data, options) {
    var _this$options, _this$options$getChun;
    Object.defineProperty(this, _abortUpload, {
      value: _abortUpload2
    });
    Object.defineProperty(this, _resumeUpload, {
      value: _resumeUpload2
    });
    Object.defineProperty(this, _createUpload, {
      value: _createUpload2
    });
    Object.defineProperty(this, _initChunks, {
      value: _initChunks2
    });
    Object.defineProperty(this, _abortController, {
      writable: true,
      value: new AbortController2()
    });
    Object.defineProperty(this, _chunks, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _chunkState, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _data, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _file, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _uploadHasStarted, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _onError, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _onSuccess, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _shouldUseMultipart, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isRestoring, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _onReject, {
      writable: true,
      value: (err) => (err == null ? void 0 : err.cause) === pausingUploadReason ? null : _classPrivateFieldLooseBase4(this, _onError)[_onError](err)
    });
    Object.defineProperty(this, _maxMultipartParts, {
      writable: true,
      value: 1e4
    });
    Object.defineProperty(this, _minPartSize, {
      writable: true,
      value: 5 * MB
    });
    Object.defineProperty(this, _onPartProgress, {
      writable: true,
      value: (index) => (ev) => {
        if (!ev.lengthComputable)
          return;
        _classPrivateFieldLooseBase4(this, _chunkState)[_chunkState][index].uploaded = ensureInt(ev.loaded);
        const totalUploaded = _classPrivateFieldLooseBase4(this, _chunkState)[_chunkState].reduce((n, c) => n + c.uploaded, 0);
        this.options.onProgress(totalUploaded, _classPrivateFieldLooseBase4(this, _data)[_data].size);
      }
    });
    Object.defineProperty(this, _onPartComplete, {
      writable: true,
      value: (index) => (etag) => {
        _classPrivateFieldLooseBase4(this, _chunks)[_chunks][index] = null;
        _classPrivateFieldLooseBase4(this, _chunkState)[_chunkState][index].etag = etag;
        _classPrivateFieldLooseBase4(this, _chunkState)[_chunkState][index].done = true;
        const part = {
          PartNumber: index + 1,
          ETag: etag
        };
        this.options.onPartComplete(part);
      }
    });
    this.options = {
      ...defaultOptions,
      ...options
    };
    (_this$options$getChun = (_this$options = this.options).getChunkSize) != null ? _this$options$getChun : _this$options.getChunkSize = defaultOptions.getChunkSize;
    _classPrivateFieldLooseBase4(this, _data)[_data] = data;
    _classPrivateFieldLooseBase4(this, _file)[_file] = options.file;
    _classPrivateFieldLooseBase4(this, _onSuccess)[_onSuccess] = this.options.onSuccess;
    _classPrivateFieldLooseBase4(this, _onError)[_onError] = this.options.onError;
    _classPrivateFieldLooseBase4(this, _shouldUseMultipart)[_shouldUseMultipart] = this.options.shouldUseMultipart;
    _classPrivateFieldLooseBase4(this, _isRestoring)[_isRestoring] = options.uploadId && options.key;
    _classPrivateFieldLooseBase4(this, _initChunks)[_initChunks]();
  }
  start() {
    if (_classPrivateFieldLooseBase4(this, _uploadHasStarted)[_uploadHasStarted]) {
      if (!_classPrivateFieldLooseBase4(this, _abortController)[_abortController].signal.aborted)
        _classPrivateFieldLooseBase4(this, _abortController)[_abortController].abort(pausingUploadReason);
      _classPrivateFieldLooseBase4(this, _abortController)[_abortController] = new AbortController2();
      _classPrivateFieldLooseBase4(this, _resumeUpload)[_resumeUpload]();
    } else if (_classPrivateFieldLooseBase4(this, _isRestoring)[_isRestoring]) {
      this.options.companionComm.restoreUploadFile(_classPrivateFieldLooseBase4(this, _file)[_file], {
        uploadId: this.options.uploadId,
        key: this.options.key
      });
      _classPrivateFieldLooseBase4(this, _resumeUpload)[_resumeUpload]();
    } else {
      _classPrivateFieldLooseBase4(this, _createUpload)[_createUpload]();
    }
  }
  pause() {
    _classPrivateFieldLooseBase4(this, _abortController)[_abortController].abort(pausingUploadReason);
    _classPrivateFieldLooseBase4(this, _abortController)[_abortController] = new AbortController2();
  }
  abort(opts) {
    if (opts != null && opts.really)
      _classPrivateFieldLooseBase4(this, _abortUpload)[_abortUpload]();
    else
      this.pause();
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  [Symbol.for("uppy test: getChunkState")]() {
    return _classPrivateFieldLooseBase4(this, _chunkState)[_chunkState];
  }
};
function _initChunks2() {
  const fileSize = _classPrivateFieldLooseBase4(this, _data)[_data].size;
  const shouldUseMultipart = typeof _classPrivateFieldLooseBase4(this, _shouldUseMultipart)[_shouldUseMultipart] === "function" ? _classPrivateFieldLooseBase4(this, _shouldUseMultipart)[_shouldUseMultipart](_classPrivateFieldLooseBase4(this, _file)[_file]) : Boolean(_classPrivateFieldLooseBase4(this, _shouldUseMultipart)[_shouldUseMultipart]);
  if (shouldUseMultipart && fileSize > _classPrivateFieldLooseBase4(this, _minPartSize)[_minPartSize]) {
    let chunkSize = Math.max(
      this.options.getChunkSize(_classPrivateFieldLooseBase4(this, _data)[_data]),
      // Math.max can take undefined but TS does not think so
      _classPrivateFieldLooseBase4(this, _minPartSize)[_minPartSize]
    );
    let arraySize = Math.floor(fileSize / chunkSize);
    if (arraySize > _classPrivateFieldLooseBase4(this, _maxMultipartParts)[_maxMultipartParts]) {
      arraySize = _classPrivateFieldLooseBase4(this, _maxMultipartParts)[_maxMultipartParts];
      chunkSize = fileSize / _classPrivateFieldLooseBase4(this, _maxMultipartParts)[_maxMultipartParts];
    }
    _classPrivateFieldLooseBase4(this, _chunks)[_chunks] = Array(arraySize);
    for (let offset = 0, j = 0; offset < fileSize; offset += chunkSize, j++) {
      const end = Math.min(fileSize, offset + chunkSize);
      const getData = () => {
        const i2 = offset;
        return _classPrivateFieldLooseBase4(this, _data)[_data].slice(i2, end);
      };
      _classPrivateFieldLooseBase4(this, _chunks)[_chunks][j] = {
        getData,
        onProgress: _classPrivateFieldLooseBase4(this, _onPartProgress)[_onPartProgress](j),
        onComplete: _classPrivateFieldLooseBase4(this, _onPartComplete)[_onPartComplete](j),
        shouldUseMultipart
      };
      if (_classPrivateFieldLooseBase4(this, _isRestoring)[_isRestoring]) {
        const size = offset + chunkSize > fileSize ? fileSize - offset : chunkSize;
        _classPrivateFieldLooseBase4(this, _chunks)[_chunks][j].setAsUploaded = () => {
          _classPrivateFieldLooseBase4(this, _chunks)[_chunks][j] = null;
          _classPrivateFieldLooseBase4(this, _chunkState)[_chunkState][j].uploaded = size;
        };
      }
    }
  } else {
    _classPrivateFieldLooseBase4(this, _chunks)[_chunks] = [{
      getData: () => _classPrivateFieldLooseBase4(this, _data)[_data],
      onProgress: _classPrivateFieldLooseBase4(this, _onPartProgress)[_onPartProgress](0),
      onComplete: _classPrivateFieldLooseBase4(this, _onPartComplete)[_onPartComplete](0),
      shouldUseMultipart
    }];
  }
  _classPrivateFieldLooseBase4(this, _chunkState)[_chunkState] = _classPrivateFieldLooseBase4(this, _chunks)[_chunks].map(() => ({
    uploaded: 0
  }));
}
function _createUpload2() {
  this.options.companionComm.uploadFile(_classPrivateFieldLooseBase4(this, _file)[_file], _classPrivateFieldLooseBase4(this, _chunks)[_chunks], _classPrivateFieldLooseBase4(this, _abortController)[_abortController].signal).then(_classPrivateFieldLooseBase4(this, _onSuccess)[_onSuccess], _classPrivateFieldLooseBase4(this, _onReject)[_onReject]);
  _classPrivateFieldLooseBase4(this, _uploadHasStarted)[_uploadHasStarted] = true;
}
function _resumeUpload2() {
  this.options.companionComm.resumeUploadFile(_classPrivateFieldLooseBase4(this, _file)[_file], _classPrivateFieldLooseBase4(this, _chunks)[_chunks], _classPrivateFieldLooseBase4(this, _abortController)[_abortController].signal).then(_classPrivateFieldLooseBase4(this, _onSuccess)[_onSuccess], _classPrivateFieldLooseBase4(this, _onReject)[_onReject]);
}
function _abortUpload2() {
  _classPrivateFieldLooseBase4(this, _abortController)[_abortController].abort();
  this.options.companionComm.abortFileUpload(_classPrivateFieldLooseBase4(this, _file)[_file]).catch((err) => this.options.log(err));
}
var MultipartUploader_default = MultipartUploader;

// node_modules/@uppy/aws-s3/lib/utils.js
function throwIfAborted(signal) {
  if (signal != null && signal.aborted) {
    throw createAbortError("The operation was aborted", {
      cause: signal.reason
    });
  }
}

// node_modules/@uppy/aws-s3/lib/createSignedURL.js
function createCanonicalRequest(_ref) {
  let {
    method = "PUT",
    CanonicalUri = "/",
    CanonicalQueryString = "",
    SignedHeaders,
    HashedPayload
  } = _ref;
  const headerKeys = Object.keys(SignedHeaders).map((k) => k.toLowerCase()).sort();
  return [method, CanonicalUri, CanonicalQueryString, ...headerKeys.map((k) => `${k}:${SignedHeaders[k]}`), "", headerKeys.join(";"), HashedPayload].join("\n");
}
var ec = new TextEncoder();
var algorithm = {
  name: "HMAC",
  hash: "SHA-256"
};
async function digest(data) {
  const {
    subtle
  } = globalThis.crypto;
  return subtle.digest(algorithm.hash, ec.encode(data));
}
async function generateHmacKey(secret) {
  const {
    subtle
  } = globalThis.crypto;
  return subtle.importKey("raw", typeof secret === "string" ? ec.encode(secret) : secret, algorithm, false, ["sign"]);
}
function arrayBufferToHexString(arrayBuffer) {
  const byteArray = new Uint8Array(arrayBuffer);
  let hexString = "";
  for (let i = 0; i < byteArray.length; i++) {
    hexString += byteArray[i].toString(16).padStart(2, "0");
  }
  return hexString;
}
async function hash(key, data) {
  const {
    subtle
  } = globalThis.crypto;
  return subtle.sign(algorithm, await generateHmacKey(key), ec.encode(data));
}
async function createSignedURL(_ref2) {
  let {
    accountKey,
    accountSecret,
    sessionToken,
    bucketName,
    Key,
    Region,
    expires,
    uploadId,
    partNumber
  } = _ref2;
  const Service = "s3";
  const host = `${Service}.${Region}.amazonaws.com`;
  const CanonicalUri = `/${bucketName}/${encodeURI(Key).replace(/[;?:@&=+$,#!'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`)}`;
  const payload = "UNSIGNED-PAYLOAD";
  const requestDateTime = (/* @__PURE__ */ new Date()).toISOString().replace(/[-:]|\.\d+/g, "");
  const date = requestDateTime.slice(0, 8);
  const scope = `${date}/${Region}/${Service}/aws4_request`;
  const url = new URL(`https://${host}${CanonicalUri}`);
  url.searchParams.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256");
  url.searchParams.set("X-Amz-Content-Sha256", payload);
  url.searchParams.set("X-Amz-Credential", `${accountKey}/${scope}`);
  url.searchParams.set("X-Amz-Date", requestDateTime);
  url.searchParams.set("X-Amz-Expires", expires);
  url.searchParams.set("X-Amz-Security-Token", sessionToken);
  url.searchParams.set("X-Amz-SignedHeaders", "host");
  if (partNumber)
    url.searchParams.set("partNumber", partNumber);
  if (uploadId)
    url.searchParams.set("uploadId", uploadId);
  url.searchParams.set("x-id", partNumber && uploadId ? "UploadPart" : "PutObject");
  const canonical = createCanonicalRequest({
    CanonicalUri,
    CanonicalQueryString: url.search.slice(1),
    SignedHeaders: {
      host
    },
    HashedPayload: payload
  });
  const hashedCanonical = arrayBufferToHexString(await digest(canonical));
  const stringToSign = [
    `AWS4-HMAC-SHA256`,
    // The algorithm used to create the hash of the canonical request.
    requestDateTime,
    // The date and time used in the credential scope.
    scope,
    // The credential scope. This restricts the resulting signature to the specified Region and service.
    hashedCanonical
    // The hash of the canonical request.
  ].join("\n");
  const kDate = await hash(`AWS4${accountSecret}`, date);
  const kRegion = await hash(kDate, Region);
  const kService = await hash(kRegion, Service);
  const kSigning = await hash(kService, "aws4_request");
  const signature = arrayBufferToHexString(await hash(kSigning, stringToSign));
  url.searchParams.set("X-Amz-Signature", signature);
  return url;
}

// node_modules/@uppy/aws-s3/lib/HTTPCommunicationQueue.js
function _classPrivateFieldLooseBase5(e, t) {
  if (!{}.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id6 = 0;
function _classPrivateFieldLooseKey6(e) {
  return "__private_" + id6++ + "_" + e;
}
function removeMetadataFromURL(urlString) {
  const urlObject = new URL(urlString);
  urlObject.search = "";
  urlObject.hash = "";
  return urlObject.href;
}
var _abortMultipartUpload = _classPrivateFieldLooseKey6("abortMultipartUpload");
var _cache = _classPrivateFieldLooseKey6("cache");
var _createMultipartUpload = _classPrivateFieldLooseKey6("createMultipartUpload");
var _fetchSignature = _classPrivateFieldLooseKey6("fetchSignature");
var _getUploadParameters = _classPrivateFieldLooseKey6("getUploadParameters");
var _listParts = _classPrivateFieldLooseKey6("listParts");
var _previousRetryDelay = _classPrivateFieldLooseKey6("previousRetryDelay");
var _requests = _classPrivateFieldLooseKey6("requests");
var _retryDelays = _classPrivateFieldLooseKey6("retryDelays");
var _sendCompletionRequest = _classPrivateFieldLooseKey6("sendCompletionRequest");
var _setS3MultipartState = _classPrivateFieldLooseKey6("setS3MultipartState");
var _uploadPartBytes = _classPrivateFieldLooseKey6("uploadPartBytes");
var _getFile = _classPrivateFieldLooseKey6("getFile");
var _shouldRetry = _classPrivateFieldLooseKey6("shouldRetry");
var _nonMultipartUpload = _classPrivateFieldLooseKey6("nonMultipartUpload");
var HTTPCommunicationQueue = class {
  constructor(_requests2, options, setS3MultipartState, getFile) {
    Object.defineProperty(this, _nonMultipartUpload, {
      value: _nonMultipartUpload2
    });
    Object.defineProperty(this, _shouldRetry, {
      value: _shouldRetry2
    });
    Object.defineProperty(this, _abortMultipartUpload, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _cache, {
      writable: true,
      value: /* @__PURE__ */ new WeakMap()
    });
    Object.defineProperty(this, _createMultipartUpload, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _fetchSignature, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _getUploadParameters, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _listParts, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _previousRetryDelay, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _requests, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _retryDelays, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _sendCompletionRequest, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _setS3MultipartState, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _uploadPartBytes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _getFile, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase5(this, _requests)[_requests] = _requests2;
    _classPrivateFieldLooseBase5(this, _setS3MultipartState)[_setS3MultipartState] = setS3MultipartState;
    _classPrivateFieldLooseBase5(this, _getFile)[_getFile] = getFile;
    this.setOptions(options);
  }
  setOptions(options) {
    const requests = _classPrivateFieldLooseBase5(this, _requests)[_requests];
    if ("abortMultipartUpload" in options) {
      _classPrivateFieldLooseBase5(this, _abortMultipartUpload)[_abortMultipartUpload] = requests.wrapPromiseFunction(options.abortMultipartUpload, {
        priority: 1
      });
    }
    if ("createMultipartUpload" in options) {
      _classPrivateFieldLooseBase5(this, _createMultipartUpload)[_createMultipartUpload] = requests.wrapPromiseFunction(options.createMultipartUpload, {
        priority: -1
      });
    }
    if ("signPart" in options) {
      _classPrivateFieldLooseBase5(this, _fetchSignature)[_fetchSignature] = requests.wrapPromiseFunction(options.signPart);
    }
    if ("listParts" in options) {
      _classPrivateFieldLooseBase5(this, _listParts)[_listParts] = requests.wrapPromiseFunction(options.listParts);
    }
    if ("completeMultipartUpload" in options) {
      _classPrivateFieldLooseBase5(this, _sendCompletionRequest)[_sendCompletionRequest] = requests.wrapPromiseFunction(options.completeMultipartUpload, {
        priority: 1
      });
    }
    if ("retryDelays" in options) {
      var _options$retryDelays;
      _classPrivateFieldLooseBase5(this, _retryDelays)[_retryDelays] = (_options$retryDelays = options.retryDelays) != null ? _options$retryDelays : [];
    }
    if ("uploadPartBytes" in options) {
      _classPrivateFieldLooseBase5(this, _uploadPartBytes)[_uploadPartBytes] = requests.wrapPromiseFunction(options.uploadPartBytes, {
        priority: Infinity
      });
    }
    if ("getUploadParameters" in options) {
      _classPrivateFieldLooseBase5(this, _getUploadParameters)[_getUploadParameters] = requests.wrapPromiseFunction(options.getUploadParameters);
    }
  }
  async getUploadId(file, signal) {
    let cachedResult;
    while ((cachedResult = _classPrivateFieldLooseBase5(this, _cache)[_cache].get(file.data)) != null) {
      try {
        return await cachedResult;
      } catch {
      }
    }
    const promise = _classPrivateFieldLooseBase5(this, _createMultipartUpload)[_createMultipartUpload](_classPrivateFieldLooseBase5(this, _getFile)[_getFile](file), signal);
    const abortPromise = () => {
      promise.abort(signal.reason);
      _classPrivateFieldLooseBase5(this, _cache)[_cache].delete(file.data);
    };
    signal.addEventListener("abort", abortPromise, {
      once: true
    });
    _classPrivateFieldLooseBase5(this, _cache)[_cache].set(file.data, promise);
    promise.then(async (result) => {
      signal.removeEventListener("abort", abortPromise);
      _classPrivateFieldLooseBase5(this, _setS3MultipartState)[_setS3MultipartState](file, result);
      _classPrivateFieldLooseBase5(this, _cache)[_cache].set(file.data, result);
    }, () => {
      signal.removeEventListener("abort", abortPromise);
      _classPrivateFieldLooseBase5(this, _cache)[_cache].delete(file.data);
    });
    return promise;
  }
  async abortFileUpload(file) {
    const result = _classPrivateFieldLooseBase5(this, _cache)[_cache].get(file.data);
    if (result == null) {
      return;
    }
    _classPrivateFieldLooseBase5(this, _cache)[_cache].delete(file.data);
    _classPrivateFieldLooseBase5(this, _setS3MultipartState)[_setS3MultipartState](file, /* @__PURE__ */ Object.create(null));
    let awaitedResult;
    try {
      awaitedResult = await result;
    } catch {
      return;
    }
    await _classPrivateFieldLooseBase5(this, _abortMultipartUpload)[_abortMultipartUpload](_classPrivateFieldLooseBase5(this, _getFile)[_getFile](file), awaitedResult);
  }
  async uploadFile(file, chunks, signal) {
    throwIfAborted(signal);
    if (chunks.length === 1 && !chunks[0].shouldUseMultipart) {
      return _classPrivateFieldLooseBase5(this, _nonMultipartUpload)[_nonMultipartUpload](file, chunks[0], signal);
    }
    const {
      uploadId,
      key
    } = await this.getUploadId(file, signal);
    throwIfAborted(signal);
    try {
      const parts = await Promise.all(chunks.map((chunk, i) => this.uploadChunk(file, i + 1, chunk, signal)));
      throwIfAborted(signal);
      return await _classPrivateFieldLooseBase5(this, _sendCompletionRequest)[_sendCompletionRequest](_classPrivateFieldLooseBase5(this, _getFile)[_getFile](file), {
        key,
        uploadId,
        parts,
        signal
      }, signal).abortOn(signal);
    } catch (err) {
      if ((err == null ? void 0 : err.cause) !== pausingUploadReason && (err == null ? void 0 : err.name) !== "AbortError") {
        this.abortFileUpload(file);
      }
      throw err;
    }
  }
  restoreUploadFile(file, uploadIdAndKey) {
    _classPrivateFieldLooseBase5(this, _cache)[_cache].set(file.data, uploadIdAndKey);
  }
  async resumeUploadFile(file, chunks, signal) {
    throwIfAborted(signal);
    if (chunks.length === 1 && chunks[0] != null && !chunks[0].shouldUseMultipart) {
      return _classPrivateFieldLooseBase5(this, _nonMultipartUpload)[_nonMultipartUpload](file, chunks[0], signal);
    }
    const {
      uploadId,
      key
    } = await this.getUploadId(file, signal);
    throwIfAborted(signal);
    const alreadyUploadedParts = await _classPrivateFieldLooseBase5(this, _listParts)[_listParts](_classPrivateFieldLooseBase5(this, _getFile)[_getFile](file), {
      uploadId,
      key,
      signal
    }, signal).abortOn(signal);
    throwIfAborted(signal);
    const parts = await Promise.all(chunks.map((chunk, i) => {
      const partNumber = i + 1;
      const alreadyUploadedInfo = alreadyUploadedParts.find((_ref) => {
        let {
          PartNumber
        } = _ref;
        return PartNumber === partNumber;
      });
      if (alreadyUploadedInfo == null) {
        return this.uploadChunk(file, partNumber, chunk, signal);
      }
      chunk == null || chunk.setAsUploaded == null || chunk.setAsUploaded();
      return {
        PartNumber: partNumber,
        ETag: alreadyUploadedInfo.ETag
      };
    }));
    throwIfAborted(signal);
    return _classPrivateFieldLooseBase5(this, _sendCompletionRequest)[_sendCompletionRequest](_classPrivateFieldLooseBase5(this, _getFile)[_getFile](file), {
      key,
      uploadId,
      parts,
      signal
    }, signal).abortOn(signal);
  }
  async uploadChunk(file, partNumber, chunk, signal) {
    throwIfAborted(signal);
    const {
      uploadId,
      key
    } = await this.getUploadId(file, signal);
    const signatureRetryIterator = _classPrivateFieldLooseBase5(this, _retryDelays)[_retryDelays].values();
    const chunkRetryIterator = _classPrivateFieldLooseBase5(this, _retryDelays)[_retryDelays].values();
    const shouldRetrySignature = () => {
      const next = signatureRetryIterator.next();
      if (next == null || next.done) {
        return null;
      }
      return next.value;
    };
    for (; ; ) {
      throwIfAborted(signal);
      const chunkData = chunk.getData();
      const {
        onProgress,
        onComplete
      } = chunk;
      let signature;
      try {
        signature = await _classPrivateFieldLooseBase5(this, _fetchSignature)[_fetchSignature](_classPrivateFieldLooseBase5(this, _getFile)[_getFile](file), {
          // Always defined for multipart uploads
          uploadId,
          key,
          partNumber,
          body: chunkData,
          signal
        }).abortOn(signal);
      } catch (err) {
        const timeout = shouldRetrySignature();
        if (timeout == null || signal.aborted) {
          throw err;
        }
        await new Promise((resolve) => setTimeout(resolve, timeout));
        continue;
      }
      throwIfAborted(signal);
      try {
        return {
          PartNumber: partNumber,
          ...await _classPrivateFieldLooseBase5(this, _uploadPartBytes)[_uploadPartBytes]({
            signature,
            body: chunkData,
            size: chunkData.size,
            onProgress,
            onComplete,
            signal
          }).abortOn(signal)
        };
      } catch (err) {
        if (!await _classPrivateFieldLooseBase5(this, _shouldRetry)[_shouldRetry](err, chunkRetryIterator))
          throw err;
      }
    }
  }
};
async function _shouldRetry2(err, retryDelayIterator) {
  var _err$source;
  const requests = _classPrivateFieldLooseBase5(this, _requests)[_requests];
  const status = err == null || (_err$source = err.source) == null ? void 0 : _err$source.status;
  if (status == null) {
    return false;
  }
  if (status === 403 && err.message === "Request has expired") {
    if (!requests.isPaused) {
      if (requests.limit === 1 || _classPrivateFieldLooseBase5(this, _previousRetryDelay)[_previousRetryDelay] == null) {
        const next = retryDelayIterator.next();
        if (next == null || next.done) {
          return false;
        }
        _classPrivateFieldLooseBase5(this, _previousRetryDelay)[_previousRetryDelay] = next.value;
      }
      requests.rateLimit(0);
      await new Promise((resolve) => setTimeout(resolve, _classPrivateFieldLooseBase5(this, _previousRetryDelay)[_previousRetryDelay]));
    }
  } else if (status === 429) {
    if (!requests.isPaused) {
      const next = retryDelayIterator.next();
      if (next == null || next.done) {
        return false;
      }
      requests.rateLimit(next.value);
    }
  } else if (status > 400 && status < 500 && status !== 409) {
    return false;
  } else if (typeof navigator !== "undefined" && navigator.onLine === false) {
    if (!requests.isPaused) {
      requests.pause();
      window.addEventListener("online", () => {
        requests.resume();
      }, {
        once: true
      });
    }
  } else {
    const next = retryDelayIterator.next();
    if (next == null || next.done) {
      return false;
    }
    await new Promise((resolve) => setTimeout(resolve, next.value));
  }
  return true;
}
async function _nonMultipartUpload2(file, chunk, signal) {
  var _ref3;
  const {
    method = "POST",
    url,
    fields,
    headers
  } = await _classPrivateFieldLooseBase5(this, _getUploadParameters)[_getUploadParameters](_classPrivateFieldLooseBase5(this, _getFile)[_getFile](file), {
    signal
  }).abortOn(signal);
  let body;
  const data = chunk.getData();
  if (method.toUpperCase() === "POST") {
    const formData = new FormData();
    Object.entries(fields).forEach((_ref2) => {
      let [key2, value] = _ref2;
      return formData.set(key2, value);
    });
    formData.set("file", data);
    body = formData;
  } else {
    body = data;
  }
  const {
    onProgress,
    onComplete
  } = chunk;
  const result = await _classPrivateFieldLooseBase5(this, _uploadPartBytes)[_uploadPartBytes]({
    signature: {
      url,
      headers,
      method
    },
    body,
    size: data.size,
    onProgress,
    onComplete,
    signal
  }).abortOn(signal);
  const key = fields == null ? void 0 : fields.key;
  _classPrivateFieldLooseBase5(this, _setS3MultipartState)[_setS3MultipartState](file, {
    key
  });
  return {
    ...result,
    location: (_ref3 = result.location) != null ? _ref3 : removeMetadataFromURL(url),
    bucket: fields == null ? void 0 : fields.bucket,
    key
  };
}

// node_modules/@uppy/aws-s3/lib/index.js
function _classPrivateFieldLooseBase6(e, t) {
  if (!{}.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id7 = 0;
function _classPrivateFieldLooseKey7(e) {
  return "__private_" + id7++ + "_" + e;
}
var packageJson2 = {
  "version": "4.2.3"
};
function assertServerError(res) {
  if (res != null && res.error) {
    const error = new Error(res.message);
    Object.assign(error, res.error);
    throw error;
  }
  return res;
}
function getExpiry(credentials) {
  const expirationDate = credentials.Expiration;
  if (expirationDate) {
    const timeUntilExpiry = Math.floor((new Date(expirationDate) - Date.now()) / 1e3);
    if (timeUntilExpiry > 9) {
      return timeUntilExpiry;
    }
  }
  return void 0;
}
function getAllowedMetadata(_ref) {
  let {
    meta,
    allowedMetaFields,
    querify = false
  } = _ref;
  const metaFields = allowedMetaFields != null ? allowedMetaFields : Object.keys(meta);
  if (!meta)
    return {};
  return Object.fromEntries(metaFields.filter((key) => meta[key] != null).map((key) => {
    const realKey = querify ? `metadata[${key}]` : key;
    const value = String(meta[key]);
    return [realKey, value];
  }));
}
var defaultOptions2 = {
  allowedMetaFields: true,
  limit: 6,
  getTemporarySecurityCredentials: false,
  shouldUseMultipart: (file) => (file.size || 0) > 100 * 1024 * 1024,
  retryDelays: [0, 1e3, 3e3, 5e3]
};
var _companionCommunicationQueue = _classPrivateFieldLooseKey7("companionCommunicationQueue");
var _client = _classPrivateFieldLooseKey7("client");
var _setClient = _classPrivateFieldLooseKey7("setClient");
var _assertHost = _classPrivateFieldLooseKey7("assertHost");
var _cachedTemporaryCredentials = _classPrivateFieldLooseKey7("cachedTemporaryCredentials");
var _getTemporarySecurityCredentials = _classPrivateFieldLooseKey7("getTemporarySecurityCredentials");
var _setS3MultipartState2 = _classPrivateFieldLooseKey7("setS3MultipartState");
var _getFile2 = _classPrivateFieldLooseKey7("getFile");
var _uploadLocalFile = _classPrivateFieldLooseKey7("uploadLocalFile");
var _getCompanionClientArgs = _classPrivateFieldLooseKey7("getCompanionClientArgs");
var _upload = _classPrivateFieldLooseKey7("upload");
var _setCompanionHeaders = _classPrivateFieldLooseKey7("setCompanionHeaders");
var _setResumableUploadsCapability = _classPrivateFieldLooseKey7("setResumableUploadsCapability");
var _resetResumableCapability = _classPrivateFieldLooseKey7("resetResumableCapability");
var AwsS3Multipart = class _AwsS3Multipart extends BasePlugin {
  constructor(uppy, _opts) {
    var _rateLimitedQueue;
    super(uppy, {
      ...defaultOptions2,
      uploadPartBytes: _AwsS3Multipart.uploadPartBytes,
      createMultipartUpload: null,
      listParts: null,
      abortMultipartUpload: null,
      completeMultipartUpload: null,
      signPart: null,
      getUploadParameters: null,
      ..._opts
    });
    Object.defineProperty(this, _getCompanionClientArgs, {
      value: _getCompanionClientArgs2
    });
    Object.defineProperty(this, _uploadLocalFile, {
      value: _uploadLocalFile2
    });
    Object.defineProperty(this, _getTemporarySecurityCredentials, {
      value: _getTemporarySecurityCredentials2
    });
    Object.defineProperty(this, _assertHost, {
      value: _assertHost2
    });
    Object.defineProperty(this, _setClient, {
      value: _setClient2
    });
    Object.defineProperty(this, _companionCommunicationQueue, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _client, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _cachedTemporaryCredentials, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _setS3MultipartState2, {
      writable: true,
      value: (file, _ref2) => {
        let {
          key,
          uploadId
        } = _ref2;
        const cFile = this.uppy.getFile(file.id);
        if (cFile == null) {
          return;
        }
        this.uppy.setFileState(file.id, {
          s3Multipart: {
            ...cFile.s3Multipart,
            key,
            uploadId
          }
        });
      }
    });
    Object.defineProperty(this, _getFile2, {
      writable: true,
      value: (file) => {
        return this.uppy.getFile(file.id) || file;
      }
    });
    Object.defineProperty(this, _upload, {
      writable: true,
      value: async (fileIDs) => {
        if (fileIDs.length === 0)
          return void 0;
        const files = this.uppy.getFilesByIds(fileIDs);
        const filesFiltered = filterNonFailedFiles(files);
        const filesToEmit = filterFilesToEmitUploadStarted(filesFiltered);
        this.uppy.emit("upload-start", filesToEmit);
        const promises = filesFiltered.map((file) => {
          if (file.isRemote) {
            const getQueue = () => this.requests;
            _classPrivateFieldLooseBase6(this, _setResumableUploadsCapability)[_setResumableUploadsCapability](false);
            const controller = new AbortController();
            const removedHandler = (removedFile) => {
              if (removedFile.id === file.id)
                controller.abort();
            };
            this.uppy.on("file-removed", removedHandler);
            const uploadPromise = this.uppy.getRequestClientForFile(file).uploadRemoteFile(file, _classPrivateFieldLooseBase6(this, _getCompanionClientArgs)[_getCompanionClientArgs](file), {
              signal: controller.signal,
              getQueue
            });
            this.requests.wrapSyncFunction(() => {
              this.uppy.off("file-removed", removedHandler);
            }, {
              priority: -1
            })();
            return uploadPromise;
          }
          return _classPrivateFieldLooseBase6(this, _uploadLocalFile)[_uploadLocalFile](file);
        });
        const upload = await Promise.allSettled(promises);
        _classPrivateFieldLooseBase6(this, _setResumableUploadsCapability)[_setResumableUploadsCapability](true);
        return upload;
      }
    });
    Object.defineProperty(this, _setCompanionHeaders, {
      writable: true,
      value: () => {
        var _classPrivateFieldLoo;
        (_classPrivateFieldLoo = _classPrivateFieldLooseBase6(this, _client)[_client]) == null || _classPrivateFieldLoo.setCompanionHeaders(this.opts.headers);
      }
    });
    Object.defineProperty(this, _setResumableUploadsCapability, {
      writable: true,
      value: (boolean) => {
        const {
          capabilities
        } = this.uppy.getState();
        this.uppy.setState({
          capabilities: {
            ...capabilities,
            resumableUploads: boolean
          }
        });
      }
    });
    Object.defineProperty(this, _resetResumableCapability, {
      writable: true,
      value: () => {
        _classPrivateFieldLooseBase6(this, _setResumableUploadsCapability)[_setResumableUploadsCapability](true);
      }
    });
    this.type = "uploader";
    this.id = this.opts.id || "AwsS3Multipart";
    _classPrivateFieldLooseBase6(this, _setClient)[_setClient](_opts);
    const dynamicDefaultOptions = {
      createMultipartUpload: this.createMultipartUpload,
      listParts: this.listParts,
      abortMultipartUpload: this.abortMultipartUpload,
      completeMultipartUpload: this.completeMultipartUpload,
      signPart: _opts != null && _opts.getTemporarySecurityCredentials ? this.createSignedURL : this.signPart,
      getUploadParameters: _opts != null && _opts.getTemporarySecurityCredentials ? this.createSignedURL : this.getUploadParameters
    };
    for (const key of Object.keys(dynamicDefaultOptions)) {
      if (this.opts[key] == null) {
        this.opts[key] = dynamicDefaultOptions[key].bind(this);
      }
    }
    this.requests = (_rateLimitedQueue = this.opts.rateLimitedQueue) != null ? _rateLimitedQueue : new RateLimitedQueue(this.opts.limit);
    _classPrivateFieldLooseBase6(this, _companionCommunicationQueue)[_companionCommunicationQueue] = new HTTPCommunicationQueue(this.requests, this.opts, _classPrivateFieldLooseBase6(this, _setS3MultipartState2)[_setS3MultipartState2], _classPrivateFieldLooseBase6(this, _getFile2)[_getFile2]);
    this.uploaders = /* @__PURE__ */ Object.create(null);
    this.uploaderEvents = /* @__PURE__ */ Object.create(null);
  }
  [Symbol.for("uppy test: getClient")]() {
    return _classPrivateFieldLooseBase6(this, _client)[_client];
  }
  setOptions(newOptions) {
    _classPrivateFieldLooseBase6(this, _companionCommunicationQueue)[_companionCommunicationQueue].setOptions(newOptions);
    super.setOptions(newOptions);
    _classPrivateFieldLooseBase6(this, _setClient)[_setClient](newOptions);
  }
  /**
   * Clean up all references for a file's upload: the MultipartUploader instance,
   * any events related to the file, and the Companion WebSocket connection.
   *
   * Set `opts.abort` to tell S3 that the multipart upload is cancelled and must be removed.
   * This should be done when the user cancels the upload, not when the upload is completed or errored.
   */
  resetUploaderReferences(fileID, opts) {
    if (this.uploaders[fileID]) {
      this.uploaders[fileID].abort({
        really: (opts == null ? void 0 : opts.abort) || false
      });
      this.uploaders[fileID] = null;
    }
    if (this.uploaderEvents[fileID]) {
      this.uploaderEvents[fileID].remove();
      this.uploaderEvents[fileID] = null;
    }
  }
  createMultipartUpload(file, signal) {
    _classPrivateFieldLooseBase6(this, _assertHost)[_assertHost]("createMultipartUpload");
    throwIfAborted(signal);
    const allowedMetaFields = getAllowedMetaFields(this.opts.allowedMetaFields, file.meta);
    const metadata = getAllowedMetadata({
      meta: file.meta,
      allowedMetaFields
    });
    return _classPrivateFieldLooseBase6(this, _client)[_client].post("s3/multipart", {
      filename: file.name,
      type: file.type,
      metadata
    }, {
      signal
    }).then(assertServerError);
  }
  listParts(file, _ref3, oldSignal) {
    var _signal;
    let {
      key,
      uploadId,
      signal
    } = _ref3;
    (_signal = signal) != null ? _signal : signal = oldSignal;
    _classPrivateFieldLooseBase6(this, _assertHost)[_assertHost]("listParts");
    throwIfAborted(signal);
    const filename = encodeURIComponent(key);
    return _classPrivateFieldLooseBase6(this, _client)[_client].get(`s3/multipart/${encodeURIComponent(uploadId)}?key=${filename}`, {
      signal
    }).then(assertServerError);
  }
  completeMultipartUpload(file, _ref4, oldSignal) {
    var _signal2;
    let {
      key,
      uploadId,
      parts,
      signal
    } = _ref4;
    (_signal2 = signal) != null ? _signal2 : signal = oldSignal;
    _classPrivateFieldLooseBase6(this, _assertHost)[_assertHost]("completeMultipartUpload");
    throwIfAborted(signal);
    const filename = encodeURIComponent(key);
    const uploadIdEnc = encodeURIComponent(uploadId);
    return _classPrivateFieldLooseBase6(this, _client)[_client].post(`s3/multipart/${uploadIdEnc}/complete?key=${filename}`, {
      parts: parts.map((_ref5) => {
        let {
          ETag,
          PartNumber
        } = _ref5;
        return {
          ETag,
          PartNumber
        };
      })
    }, {
      signal
    }).then(assertServerError);
  }
  async createSignedURL(file, options) {
    const data = await _classPrivateFieldLooseBase6(this, _getTemporarySecurityCredentials)[_getTemporarySecurityCredentials](options);
    const expires = getExpiry(data.credentials) || 604800;
    const {
      uploadId,
      key,
      partNumber
    } = options;
    return {
      method: "PUT",
      expires,
      fields: {},
      url: `${await createSignedURL({
        accountKey: data.credentials.AccessKeyId,
        accountSecret: data.credentials.SecretAccessKey,
        sessionToken: data.credentials.SessionToken,
        expires,
        bucketName: data.bucket,
        Region: data.region,
        Key: key != null ? key : `${crypto.randomUUID()}-${file.name}`,
        uploadId,
        partNumber
      })}`,
      // Provide content type header required by S3
      headers: {
        "Content-Type": file.type
      }
    };
  }
  signPart(file, _ref6) {
    let {
      uploadId,
      key,
      partNumber,
      signal
    } = _ref6;
    _classPrivateFieldLooseBase6(this, _assertHost)[_assertHost]("signPart");
    throwIfAborted(signal);
    if (uploadId == null || key == null || partNumber == null) {
      throw new Error("Cannot sign without a key, an uploadId, and a partNumber");
    }
    const filename = encodeURIComponent(key);
    return _classPrivateFieldLooseBase6(this, _client)[_client].get(`s3/multipart/${encodeURIComponent(uploadId)}/${partNumber}?key=${filename}`, {
      signal
    }).then(assertServerError);
  }
  abortMultipartUpload(file, _ref7) {
    let {
      key,
      uploadId,
      signal
    } = _ref7;
    _classPrivateFieldLooseBase6(this, _assertHost)[_assertHost]("abortMultipartUpload");
    const filename = encodeURIComponent(key);
    const uploadIdEnc = encodeURIComponent(uploadId);
    return _classPrivateFieldLooseBase6(this, _client)[_client].delete(`s3/multipart/${uploadIdEnc}?key=${filename}`, void 0, {
      signal
    }).then(assertServerError);
  }
  getUploadParameters(file, options) {
    _classPrivateFieldLooseBase6(this, _assertHost)[_assertHost]("getUploadParameters");
    const {
      meta
    } = file;
    const {
      type,
      name: filename
    } = meta;
    const allowedMetaFields = getAllowedMetaFields(this.opts.allowedMetaFields, file.meta);
    const metadata = getAllowedMetadata({
      meta,
      allowedMetaFields,
      querify: true
    });
    const query = new URLSearchParams({
      filename,
      type,
      ...metadata
    });
    return _classPrivateFieldLooseBase6(this, _client)[_client].get(`s3/params?${query}`, options);
  }
  static async uploadPartBytes(_ref8) {
    let {
      signature: {
        url,
        expires,
        headers,
        method = "PUT"
      },
      body,
      size = body.size,
      onProgress,
      onComplete,
      signal
    } = _ref8;
    throwIfAborted(signal);
    if (url == null) {
      throw new Error("Cannot upload to an undefined URL");
    }
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open(method, url, true);
      if (headers) {
        Object.keys(headers).forEach((key) => {
          xhr.setRequestHeader(key, headers[key]);
        });
      }
      xhr.responseType = "text";
      if (typeof expires === "number") {
        xhr.timeout = expires * 1e3;
      }
      function onabort() {
        xhr.abort();
      }
      function cleanup() {
        signal == null || signal.removeEventListener("abort", onabort);
      }
      signal == null || signal.addEventListener("abort", onabort);
      xhr.upload.addEventListener("progress", (ev) => {
        onProgress(ev);
      });
      xhr.addEventListener("abort", () => {
        cleanup();
        reject(createAbortError());
      });
      xhr.addEventListener("timeout", () => {
        cleanup();
        const error = new Error("Request has expired");
        error.source = {
          status: 403
        };
        reject(error);
      });
      xhr.addEventListener("load", () => {
        cleanup();
        if (xhr.status === 403 && xhr.responseText.includes("<Message>Request has expired</Message>")) {
          const error = new Error("Request has expired");
          error.source = xhr;
          reject(error);
          return;
        }
        if (xhr.status < 200 || xhr.status >= 300) {
          const error = new Error("Non 2xx");
          error.source = xhr;
          reject(error);
          return;
        }
        onProgress == null || onProgress({
          loaded: size,
          lengthComputable: true
        });
        const arr = xhr.getAllResponseHeaders().trim().split(/[\r\n]+/);
        const headersMap = {
          __proto__: null
        };
        for (const line of arr) {
          const parts = line.split(": ");
          const header = parts.shift();
          const value = parts.join(": ");
          headersMap[header] = value;
        }
        const {
          etag,
          location: location2
        } = headersMap;
        if (method.toUpperCase() === "POST" && location2 == null) {
          console.error("@uppy/aws-s3: Could not read the Location header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3/#setting-up-your-s3-bucket");
        }
        if (etag == null) {
          console.error("@uppy/aws-s3: Could not read the ETag header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3/#setting-up-your-s3-bucket");
          return;
        }
        onComplete == null || onComplete(etag);
        resolve({
          ...headersMap,
          ETag: etag
          // keep capitalised ETag for backwards compatiblity
        });
      });
      xhr.addEventListener("error", (ev) => {
        cleanup();
        const error = new Error("Unknown error");
        error.source = ev.target;
        reject(error);
      });
      xhr.send(body);
    });
  }
  install() {
    _classPrivateFieldLooseBase6(this, _setResumableUploadsCapability)[_setResumableUploadsCapability](true);
    this.uppy.addPreProcessor(_classPrivateFieldLooseBase6(this, _setCompanionHeaders)[_setCompanionHeaders]);
    this.uppy.addUploader(_classPrivateFieldLooseBase6(this, _upload)[_upload]);
    this.uppy.on("cancel-all", _classPrivateFieldLooseBase6(this, _resetResumableCapability)[_resetResumableCapability]);
  }
  uninstall() {
    this.uppy.removePreProcessor(_classPrivateFieldLooseBase6(this, _setCompanionHeaders)[_setCompanionHeaders]);
    this.uppy.removeUploader(_classPrivateFieldLooseBase6(this, _upload)[_upload]);
    this.uppy.off("cancel-all", _classPrivateFieldLooseBase6(this, _resetResumableCapability)[_resetResumableCapability]);
  }
};
function _setClient2(opts) {
  if (opts == null || !("endpoint" in opts || "companionUrl" in opts || "headers" in opts || "companionHeaders" in opts || "cookiesRule" in opts || "companionCookiesRule" in opts))
    return;
  if ("companionUrl" in opts && !("endpoint" in opts)) {
    this.uppy.log("`companionUrl` option has been removed in @uppy/aws-s3, use `endpoint` instead.", "warning");
  }
  if ("companionHeaders" in opts && !("headers" in opts)) {
    this.uppy.log("`companionHeaders` option has been removed in @uppy/aws-s3, use `headers` instead.", "warning");
  }
  if ("companionCookiesRule" in opts && !("cookiesRule" in opts)) {
    this.uppy.log("`companionCookiesRule` option has been removed in @uppy/aws-s3, use `cookiesRule` instead.", "warning");
  }
  if ("endpoint" in opts) {
    _classPrivateFieldLooseBase6(this, _client)[_client] = new RequestClient(this.uppy, {
      pluginId: this.id,
      provider: "AWS",
      companionUrl: this.opts.endpoint,
      companionHeaders: this.opts.headers,
      companionCookiesRule: this.opts.cookiesRule
    });
  } else {
    if ("headers" in opts) {
      _classPrivateFieldLooseBase6(this, _setCompanionHeaders)[_setCompanionHeaders]();
    }
    if ("cookiesRule" in opts) {
      _classPrivateFieldLooseBase6(this, _client)[_client].opts.companionCookiesRule = opts.cookiesRule;
    }
  }
}
function _assertHost2(method) {
  if (!_classPrivateFieldLooseBase6(this, _client)[_client]) {
    throw new Error(`Expected a \`endpoint\` option containing a URL, or if you are not using Companion, a custom \`${method}\` implementation.`);
  }
}
async function _getTemporarySecurityCredentials2(options) {
  throwIfAborted(options == null ? void 0 : options.signal);
  if (_classPrivateFieldLooseBase6(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials] == null) {
    const {
      getTemporarySecurityCredentials
    } = this.opts;
    if (getTemporarySecurityCredentials === true) {
      _classPrivateFieldLooseBase6(this, _assertHost)[_assertHost]("getTemporarySecurityCredentials");
      _classPrivateFieldLooseBase6(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials] = _classPrivateFieldLooseBase6(this, _client)[_client].get("s3/sts", options).then(assertServerError);
    } else {
      _classPrivateFieldLooseBase6(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials] = getTemporarySecurityCredentials(options);
    }
    _classPrivateFieldLooseBase6(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials] = await _classPrivateFieldLooseBase6(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials];
    setTimeout(() => {
      _classPrivateFieldLooseBase6(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials] = null;
    }, (getExpiry(_classPrivateFieldLooseBase6(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials].credentials) || 0) * 500);
  }
  return _classPrivateFieldLooseBase6(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials];
}
function _uploadLocalFile2(file) {
  var _this = this;
  return new Promise((resolve, reject) => {
    const onProgress = (bytesUploaded, bytesTotal) => {
      var _latestFile$progress$;
      const latestFile = this.uppy.getFile(file.id);
      this.uppy.emit("upload-progress", latestFile, {
        uploadStarted: (_latestFile$progress$ = latestFile.progress.uploadStarted) != null ? _latestFile$progress$ : 0,
        bytesUploaded,
        bytesTotal
      });
    };
    const onError = (err) => {
      this.uppy.log(err);
      this.uppy.emit("upload-error", file, err);
      this.resetUploaderReferences(file.id);
      reject(err);
    };
    const onSuccess = (result) => {
      const uploadResp = {
        body: {
          ...result
        },
        status: 200,
        uploadURL: result.location
      };
      this.resetUploaderReferences(file.id);
      this.uppy.emit("upload-success", _classPrivateFieldLooseBase6(this, _getFile2)[_getFile2](file), uploadResp);
      if (result.location) {
        this.uppy.log(`Download ${file.name} from ${result.location}`);
      }
      resolve();
    };
    const upload = new MultipartUploader_default(file.data, {
      // .bind to pass the file object to each handler.
      companionComm: _classPrivateFieldLooseBase6(this, _companionCommunicationQueue)[_companionCommunicationQueue],
      log: function() {
        return _this.uppy.log(...arguments);
      },
      getChunkSize: this.opts.getChunkSize ? this.opts.getChunkSize.bind(this) : void 0,
      onProgress,
      onError,
      onSuccess,
      onPartComplete: (part) => {
        this.uppy.emit("s3-multipart:part-uploaded", _classPrivateFieldLooseBase6(this, _getFile2)[_getFile2](file), part);
      },
      file,
      shouldUseMultipart: this.opts.shouldUseMultipart,
      ...file.s3Multipart
    });
    this.uploaders[file.id] = upload;
    const eventManager = new EventManager(this.uppy);
    this.uploaderEvents[file.id] = eventManager;
    eventManager.onFileRemove(file.id, (removed) => {
      upload.abort();
      this.resetUploaderReferences(file.id, {
        abort: true
      });
      resolve(`upload ${removed} was removed`);
    });
    eventManager.onCancelAll(file.id, () => {
      upload.abort();
      this.resetUploaderReferences(file.id, {
        abort: true
      });
      resolve(`upload ${file.id} was canceled`);
    });
    eventManager.onFilePause(file.id, (isPaused) => {
      if (isPaused) {
        upload.pause();
      } else {
        upload.start();
      }
    });
    eventManager.onPauseAll(file.id, () => {
      upload.pause();
    });
    eventManager.onResumeAll(file.id, () => {
      upload.start();
    });
    upload.start();
  });
}
function _getCompanionClientArgs2(file) {
  var _file$remote;
  return {
    ...(_file$remote = file.remote) == null ? void 0 : _file$remote.body,
    protocol: "s3-multipart",
    size: file.data.size,
    metadata: file.meta
  };
}
AwsS3Multipart.VERSION = packageJson2.version;
export {
  AwsS3Multipart as default
};
//# sourceMappingURL=@uppy_aws-s3.js.map
